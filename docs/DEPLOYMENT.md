# Deployment Guide (Dokploy)

Проект использует **Dokploy** для управления контейнерами и автоматизации деплоя. 

## 1. Процесс обновления
Деплой настроен по модели **Push-to-Deploy**:
1. Разработчик делает пуш в ветку `main`.
2. Dokploy на сервере фиксирует изменения, делает `git pull` и пересобирает контейнеры согласно `docker-compose.prod.yml`.

> [!IMPORTANT]
> Перед пушем убедитесь, что Git-статус на сервере «чистый». Если вы правили файлы (например, `docker-compose.prod.yml`) вручную через SSH, пуш может не пройти.

## 2. Синхронизация окружения `.env`
Файлы `.env` не хранятся в Git. 
- **Локально**: Используйте `.env` для разработки.
- **На сервере**: Переменные управляются через панель управления Dokploy (секция Environment Variables).
- **Синхронизация**: При добавлении новых ключей (например, API ключи AI), их нужно добавить **и локально, и в Dokploy**.

## 3. Инфраструктура
- **Traefik**: Используется в качестве Reverse Proxy. Конфигурация роутинга и SSL (LetsEncrypt) находится в метках (labels) сервисов в `docker-compose.prod.yml`.
- **База данных**: PostgreSQL (pgvector) работает в отдельном контейнере. Данные хранятся в Docker Volume `db_data`.

## 5. Troubleshooting (Решение проблем)

### Конфликт портов с Dokploy
Если фронтенд не запускается с ошибкой `port 3000 is already in use`:
*   **Причина**: Dokploy сам использует порт 3000 для внутренней панели.
*   **Решение**: В `docker-compose.prod.yml` удалите секцию `ports: ["3000:3000"]`. Доступ к фронтенду должен осуществляться только через Traefik (метки `Host('td-rss.ru')`).

### Потеря данных каталога
Если после деплоя каталог пуст:
1. Проверьте volumes в `docker-compose.prod.yml`.
2. Убедитесь, что используются **внешние** тома (например, `russtanko-russtankoprod-colyja_db_data`), а не локальные пути, если база уже была инициализирована в Dokploy.
3. Проверьте переменную `NEXT_PUBLIC_API_URL`. Она должна указывать на `https://api.td-rss.ru` для работы клиентских компонентов (FAQ, Поиск).
